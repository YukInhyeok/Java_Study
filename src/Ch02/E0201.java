package Ch02;

class Car{
	int speed;
}

public class E0201 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		/*	<= 주석
1. 객체지향과 절차적 프로그래밍 방식
 - 시뮬라 프로그래밍 언어 <= 객체지향 프로그래밍 언어 원조
 - 객체지향 프로그래밍 언어 : 클래스를 생성하고 클래스로부터 객체를 만들어 객체 간의 상호 작용을 이용
 - 특징 : 데이터 -> 필드(변수, 속성)
 		 절차(동작, 행동) -> 메소드(함수)
 		 클래스 구성 = 필드 + 메소드, 메소드, 필드 
		 
2. 객체
 - 정의된 클래스를 가져와서 사용하기 위해 만든 객체
 - 객체 생성
   ex)	Car c = new Car();
   				===========
   				|  객체를 만든다. 인스턴스한다. new 연산자를 이용해서 Car 객체를 만든다.
   				|
   				| => 참조변수, 레퍼런스 변수 
   - 객체 사용방법
     객체.필드 => c.speed;
     객체.메소드 => c.speedUp();
     
 3. 객체지향프로그래밍 특징
  - 추상화 : 현실 세계의 사실에서 주어진 문제의 중요한 측면을 주목하여 설명하는 방식
    추상화 과정 : 실세계의 객체에서 불필요한 부분은 제거하고 필요한 부분만 간결하고 이해하기 쉽게 클래스로 만드는 작업
 	 ex) int sum(a, b){
 	 		return a+b;
 	 	}
 	 	
 - 캡슐화 : 객체와 객체 간의 의사 소통을 위한 정보만을 노출시키고 실제 내부 구현정보는 숨기는 원리
   캡슐화 과정 : 클래스 내부 구현을 외부에 숨기는 정보 은닉 이 발생
   정보은닉 => 접근지정자 : public, privacy, protected, default
   
 - 상속 : 객체지향만의 고유한 특징
   특징 : 클래스를 계층적으로 체계화할 수 있다.
   		 기존 클래스로부터 확장이 쉽다.

 - 다형성 : 같은 타입이지만 실행 결과 다양한 객체를 이용할 수 있는 성질
 	ex) 오버로딩, 오버라이딩
   오버로딩 : 동일 클래스에서 동일한 이름의 함수를 생성, 매개변수의 자료타입이 틀리거나 매개변수의 개수가 다르면 된다.
   ex) int sum(int a,int b){
 	 		return a+b;
 	 	}
 	 	
 	 	int sum(int a){
 	 		return a;
 	 	}
 	 	
 	 	double sum(double a, double b){
 	 		return a+b;
 	 	}
 	 	
 	 	double sum(double b){
 	 		return b;
 	 	}
 	 	
 	 오버라이딩 : 여러 개의 클래스에서 동일한 함수를 사용하고자 할 때 

		 */
	}

}
